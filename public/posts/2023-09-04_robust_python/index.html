<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How to Write Python Code That Doesn’t Break: A Guide to Robustness | blog.oll.is</title><meta name=keywords content="Python,Robust Code,Best Practices,Coding Standards"><meta name=description content="This guide offers insights on code organization, error handling, testing, and more, ensuring your Python projects stand the test of time."><meta name=author content="Nicholas Ollis"><link rel=canonical href=https://blog.oll.is/posts/2023-09-04_robust_python/><link crossorigin=anonymous href=/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.oll.is/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.oll.is/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.oll.is/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.oll.is/apple-touch-icon.png><link rel=mask-icon href=https://blog.oll.is/favicon-16x16.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="How to Write Python Code That Doesn’t Break: A Guide to Robustness"><meta property="og:description" content="This guide offers insights on code organization, error handling, testing, and more, ensuring your Python projects stand the test of time."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.oll.is/posts/2023-09-04_robust_python/"><meta property="og:image" content="https://blog.oll.is/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-08T12:49:12-06:00"><meta property="article:modified_time" content="2023-09-08T12:49:12-06:00"><meta property="og:site_name" content="blog.oll.is"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.oll.is/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="How to Write Python Code That Doesn’t Break: A Guide to Robustness"><meta name=twitter:description content="This guide offers insights on code organization, error handling, testing, and more, ensuring your Python projects stand the test of time."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.oll.is/posts/"},{"@type":"ListItem","position":3,"name":"How to Write Python Code That Doesn’t Break: A Guide to Robustness","item":"https://blog.oll.is/posts/2023-09-04_robust_python/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How to Write Python Code That Doesn’t Break: A Guide to Robustness","name":"How to Write Python Code That Doesn’t Break: A Guide to Robustness","description":"This guide offers insights on code organization, error handling, testing, and more, ensuring your Python projects stand the test of time.","keywords":["Python","Robust Code","Best Practices","Coding Standards"],"articleBody":" Introduction Why Robust Code Matters In the realm of software development, robust code serves as the bedrock of reliable and efficient systems. It’s more than just writing code that “works”; it’s about crafting code that can withstand a range of challenges including unexpected inputs, system changes, and long-term scaling. Robust code is integral for long-term maintainability, reducing technical debt, and creating a codebase that is not only functional but also resilient to bugs and errors. In a language as versatile as Python, which finds applications across various domains, the importance of robust code becomes even more pronounced.\nThe Importance of Discipline in Python Python’s flexibility and ease of use make it accessible for a wide range of applications, from web development to machine learning to automation. However, this very versatility can be a double-edged sword. The internet is rife with Python code examples that, while functional, may not follow best practices. For those new to Python or coming from different domains, these suboptimal examples can set a misleading precedent. That’s why discipline is paramount. Being disciplined means adhering to best practices even when Python’s flexibility allows you to bypass them. It’s about going the extra mile to make your code not just functional, but robust, maintainable, and a pleasure to work with. This disciplined approach is foundational to all the robust coding practices that follow.\nWhat Is ‘Robust Code’ In Python, robust code is a combination of resilience, maintainability, and readability. Resilient code can gracefully handle unexpected situations; maintainable code is structured to allow easy updates and debugging; readable code is self-explanatory and easy for other developers to understand. When you achieve these three pillars, you create a robust codebase that serves as a strong foundation for any project, big or small.\nCode Organization Modularization In Python, modular code is not just a best practice—it’s a sanity-saving necessity, especially for larger projects. Modularization involves breaking down your code into separate functions, modules, and packages, each responsible for a specific piece of functionality. This makes your code easier to test, debug, and extend. For example, a function that calculates the area of a circle should only do just that, making it reusable and easier to test.\n# Good Practice def calculate_area(radius): return 3.14159 * radius * radius Naming Conventions Good naming conventions are like good hygiene for your code; they make it easier to read, understand, and collaborate on. Python has a set of naming conventions outlined in PEP 8, which most Pythonistas try to follow.\nFor classes, use CamelCase:\nGood: class UserProfile: Bad: class user_profile: For functions and parameters, use snake_case:\nGood: def calculate_area(radius): Bad: def CalculateArea(Radius): For private methods and private instance variables, prepend a single underscore:\nGood: _private_method(), _private_variable Bad: privatemethod(), privateVariable By adhering to these naming conventions, you make your code more accessible and understandable to other Python developers, thereby contributing to its robustness.\nMethod Length: Keep It Short and Sweet One of the simplest yet most impactful measures of code organization is the length of your methods or functions. A common best practice is to keep method lengths between 20 to 30 lines. This isn’t a strict rule, but rather a guideline to encourage developers to write methods that do one thing and do it well.\nShorter methods have several advantages:\nReadability: They are easier to read and understand. When a method is concise, its purpose is usually clear. Maintainability: Smaller, focused methods are easier to modify without introducing bugs. Reusability: Short methods that perform a specific function are more likely to be reusable in different parts of the codebase. Testability: Methods that stick to a single responsibility are simpler to test, leading to more robust code. It’s worth noting that, sometimes, a method may need to exceed this guideline, especially if making it shorter would compromise clarity. However, if you regularly find yourself writing lengthy methods, it might be an indicator to reconsider how you’re structuring your code.\n# Good Practice def add_numbers(a, b): return a + b # Potential Red Flag def process_data(data): # ... 50 lines of data processing ... In the example above, the add_numbers function is concise and has a clear purpose, while the process_data function might be doing too much and could potentially be broken down into smaller, more focused methods.\nError Handling Python’s Error-Prone Behavior Before diving into best practices for error handling, it’s crucial to understand that Python can be error-prone in ways that might differ from other programming languages. For example, when searching for an item in an array, languages like C++ or JavaScript return a value like -1 to indicate the item is not found. However, Python throws a ValueError exception in such cases. This behavior necessitates a more proactive approach to error handling.\n// C++ returns -1 when an item is not found in an array // C++ Code std::vector\u003cint\u003e v = {1, 2, 3}; auto it = std::find(v.begin(), v.end(), 4); if (it != v.end()) { // Found } else { // Not found, it would be v.end() } # Python throws an error when an item is not found in a list # Python Code arr = [1, 2, 3] try: index = arr.index(4) except ValueError: print(\"Item not found.\") Being aware of these idiosyncrasies is the first step in writing robust Python code that can handle and recover from errors gracefully.\nException Handling One of the hallmarks of robust code is its ability to anticipate and gracefully handle errors. In Python, this is typically done through exception handling using the try, except, finally blocks. Effective exception handling prevents your program from crashing when it encounters an error, allowing it to either recover or exit gracefully, providing useful information about what went wrong. This is invaluable for debugging and for providing meaningful feedback to users.\n# Example of Exception Handling try: result = 10 / 0 except ZeroDivisionError: print(\"Caught a division by zero error.\") finally: print(\"Cleanup code, if any, goes here.\") Logging Logging is another critical component of robust code. While exceptions handle the “exceptional” cases, logging helps you understand the regular flow and the anomalies in your program. Effective logging can help you debug errors, understand program flow, and even gather usage statistics. Python’s built-in logging library is a versatile tool for various logging levels (DEBUG, INFO, WARNING, ERROR, CRITICAL).\n# Example of Logging import logging logging.basicConfig(level=logging.INFO) def divide(a, b): try: result = a / b except ZeroDivisionError: logging.error(\"Division by zero!\") return None return result Using Types for Robustness Static Typing Python, traditionally a dynamically typed language, introduced optional static typing in Python 3.5 via PEP 484. While the Python runtime itself doesn’t enforce these type hints, they serve multiple purposes that contribute to writing robust code. First, type hints make your code self-documenting. Anyone reading the code can immediately understand what types of arguments a function expects and what it returns, making the code more maintainable and less prone to bugs. Second, type hints enable better IDE support. Features like auto-completion, linting, and error checking become more accurate when the IDE knows the expected types. Last but not least, type hints allow for early detection of bugs. Tools like mypy can be used to statically analyze your code, catching potential type errors before the code is even run.\n# Example of Static Typing from typing import List def sum_elements(elements: List[int]) -\u003e int: return sum(elements) # Using mypy for static type checking # Command: mypy your_script.py Efficiency in Iteration List Comprehensions Python’s list comprehensions are not just syntactic sugar; they are a more efficient way to perform operations on lists (or any iterable), compared to traditional for loops. The speed advantage comes from the internal optimizations that Python performs, reducing the overhead of function calls and lookups in the global namespace. This might not be noticeable in smaller lists, but for larger datasets, the difference can be significant.\nList comprehensions are also more readable and concise, allowing you to express complex transformations in a single line of code. However, it’s important to strike a balance. Overly complex list comprehensions can become hard to read and maintain.\n# Using a for loop squares = [] for x in range(10): squares.append(x * x) # Using List Comprehension squares = [x * x for x in range(10)] # Complex example (not recommended for readability) result = [(x, y) for x in range(3) for y in range(3) if x != y] By opting for list comprehensions where appropriate, you not only make your code more efficient but also contribute to its readability and maintainability, thereby enhancing its robustness.\nDictionary Comprehensions Just like list comprehensions, Python also offers dictionary comprehensions to create dictionaries in a more efficient and readable manner. Dictionary comprehensions are a way to transform one dictionary into another dictionary, filtering keys, and values and applying a function to the keys and values. They offer the same benefits as list comprehensions: internal optimizations for better performance and concise, readable code.\nUsing dictionary comprehensions, you can transform complex loops that involve dictionary keys and values into a single line of code. However, as with list comprehensions, keeping them simple is essential for readability and maintainability.\n# Using a for loop to create a dictionary squares_dict = {} for x in range(1, 6): squares_dict[x] = x * x # Using Dictionary Comprehension squares_dict = {x: x * x for x in range(1, 6)} # Complex example (not recommended for readability) result_dict = {x: 'even' if x % 2 == 0 else 'odd' for x in range(1, 6)} By employing list and dictionary comprehensions where they make sense, you contribute to the efficiency, readability, and robustness of your Python code.\nProtocols and Class Signatures Defining Protocols and Duck Typing In Python, the concept of protocols plays a significant role in writing code that is both robust and maintainable. At its core, a protocol specifies a contract that classes should adhere to, much like an interface in other programming languages. However, Python’s dynamic nature has always allowed for a more lenient approach known as “duck typing.”\nDuck typing is a programming concept where the type or class of an object is determined by its behavior (methods and properties) rather than its class inheritance. While this is a powerful feature, it can lead to issues if the expected behavior is not clearly defined or understood.\n# Duck Typing Example in Python class Bird: def make_sound(self): print(\"Some generic bird sound\") class Duck(Bird): def make_sound(self): print(\"Quack\") def animal_sound(animal): animal.make_sound() animal = Duck() animal_sound(animal) # Output: Quack Duck typing is not unique to Python; it’s also prevalent in languages like Ruby, JavaScript, and Groovy. However, what sets Python apart is its support for making these implicit contracts explicit through protocols and type hints.\nTo mitigate such issues, Python allows for making these implicit “contracts” explicit through protocols. Here’s an example of an implicit form of a protocol:\n# Implicit Protocol Example from typing import Protocol class Drawable(Protocol): def draw(self) -\u003e None: ... # A class adhering to the Drawable protocol implicitly class Circle: def draw(self) -\u003e None: print(\"Drawing a circle.\") Protocol Naming Conventions When it comes to naming protocols, adopting an action-oriented convention with an “-able” suffix (e.g., Drawable, Iterable, Callable) can be helpful. This makes it clear what behavior is expected from a class that adheres to the protocol.\nClass Signatures While Python’s flexibility allows you to be implicit about adherence to a protocol, adopting a disciplined approach of being explicit in your class signatures elevates the robustness of your code. Explicitly stating that a class adheres to a protocol removes any ambiguity and assumptions, making the code more straightforward to read, debug, and maintain.\n# Explicitly stating that Circle adheres to the Drawable protocol class Circle(Drawable): def draw(self) -\u003e None: print(\"Drawing a circle.\") By taking the extra step to define protocols and explicitly mention them in your class signatures, you create a codebase that is easier to navigate, less prone to errors, and more maintainable in the long run.\nTesting The Non-Negotiable Nature of Unit Testing While various aspects of coding best practices may be subject to interpretation or specific use-cases, the role of unit testing is non-negotiable for writing robust code. At a minimum, “happy path” testing, which tests the expected behavior under normal conditions, should always be in place. These basic tests not only verify that your code works as intended but also lay the groundwork for future testing. When bugs are discovered, having an existing unit testing framework makes it straightforward to add new tests that capture these specific issues. This ensures that once a bug is fixed, it stays fixed, enhancing the code’s long-term reliability.\nUnit Testing in Depth Unit tests are geared towards verifying the smallest units of code in isolation—often individual methods or functions. These tests serve multiple purposes:\nSafety Net: Unit tests catch regressions and errors before they reach production, acting as a first line of defense against bugs. Documentation: Well-written unit tests serve as a form of documentation, clearly outlining what each function or method is supposed to accomplish. Simplifies Debugging: When a test fails, you only need to consider the latest changes, making debugging quicker and easier. In Python, you can write unit tests using the built-in unittest framework, or you can use third-party libraries like pytest for more advanced features and simpler syntax.\n# Example of a simple unit test using unittest import unittest def add(a, b): return a + b class TestAddition(unittest.TestCase): def test_add_positive_numbers(self): self.assertEqual(add(2, 3), 5) def test_add_zero(self): self.assertEqual(add(0, 0), 0) def test_add_negative_numbers(self): self.assertEqual(add(-1, -1), -2) Mocking: An Essential for Isolated Testing Mocking is a powerful technique for isolating the code under test. By replacing external dependencies with mock objects, you can focus solely on the logic you’re testing. This is crucial for several reasons:\nIsolation: Mocking external services or modules ensures that your tests are not affected by their behavior or state. Speed: Tests run faster because they don’t have to wait for real database queries or API calls. Reliability: Mocking creates a controlled environment for your tests, ensuring that they produce consistent results. Python’s unittest library includes a Mock class for creating simple object mocks. For more fine-grained control over object behavior, libraries like pytest-mock or unittest.mock offer advanced features like spy objects and mock patching.\n# Example of mocking using unittest from unittest import TestCase, mock def fetch_data(api_client): return api_client.get_data() class TestFetchData(TestCase): @mock.patch('module_name.api_client') def test_fetch_data(self, mock_client): mock_client.get_data.return_value = 'some data' result = fetch_data(mock_client) self.assertEqual(result, 'some data') By making unit testing and mocking non-negotiable parts of your development process, you’re not just writing code—you’re crafting robust, reliable, and maintainable software.\nDependency Management and Docker In Python projects, dependency management is essential for ensuring consistent behavior across different environments. The requirements.txt file is a widely used method for specifying project dependencies and their versions.\nBest Practices with requirements.txt Pin Versions: Specifying exact package versions ensures that your application behaves consistently across different setups. # requirements.txt with pinned versions Flask==1.1.2 Use Comments: Comments in requirements.txt can describe why a particular package or version is necessary, aiding future maintenance. # requirements.txt with comments Flask==1.1.2 # Needed for web API Virtual Environments Python’s native virtual environments, such as those created using venv, are a common way to isolate project-specific dependencies. While effective, they only handle Python packages and not other system dependencies.\n# Creating a virtual environment python -m venv myenv Docker: The Superior Alternative for Isolation Docker containers take environment isolation to the next level. Unlike Python virtual environments, which only isolate Python packages, Docker containers encapsulate the entire application environment. This includes the operating system, system libraries, databases, and other services your application might interact with.\nHere’s why Docker should be your go-to choice:\nEnvironment Consistency: Docker ensures your application behaves the same way regardless of where it runs, eliminating the “it works on my machine” problem. Ease of Deployment: Docker containers can be easily shared, making deployment across different systems or servers straightforward. Microservices: For applications based on micro-services architecture, Docker simplifies service management, as each service can reside in its own container. # Example Dockerfile for a Python application FROM python:3.8 WORKDIR /app COPY requirements.txt . RUN pip install --no-cache-dir -r requirements.txt COPY . . CMD [\"python\", \"your_app.py\"] By opting for Docker over traditional Python virtual environments, you’re not just isolating your Python application; you’re making it portable, easy to deploy, and robust, thereby ensuring its reliability and maintainability.\nDocumentation The Unsung Hero of Robust Code While code is written for machines to execute, it is read and understood by humans. Good documentation acts as a guide, making it easier for you (and others) to understand the code’s purpose, architecture, and nuances. Without adequate documentation, even the most well-designed codebase can become a labyrinth that is hard to navigate and risky to modify.\nInline Comments and Docstrings Inline comments and docstrings should be the starting point of any documentation effort. Comments can offer context or explain complex pieces of code, while docstrings provide an overview of modules, classes, and functions.\ndef calculate_area(length: float, width: float) -\u003e float: \"\"\" Calculate the area of a rectangle. This function takes the length and width of a rectangle and returns its area. The function assumes that the parameters provided are positive numbers. Zero is considered an acceptable value for either length or width but will result in an area of zero. :param length: The length of the rectangle. :type length: float :param width: The width of the rectangle. :type width: float :return: The area of the rectangle. :rtype: float :raises ValueError: If either length or width is negative. :Example: \u003e\u003e\u003e calculate_area(10, 5) 50.0 \u003e\u003e\u003e calculate_area(0, 5) 0.0 \u003e\u003e\u003e calculate_area(-1, 5) ValueError: Dimensions should be non-negative. \"\"\" if length \u003c 0 or width \u003c 0: raise ValueError(\"Dimensions should be non-negative.\") return length * width README Files Every project should have a README file that serves as an introduction to your project. It should contain essential information like what the project does, how to set it up, and how to use it, providing a roadmap to your codebase.\nAPI Documentation For larger projects or libraries, generating API documentation using tools like Sphinx can offer a more organized and navigable format. These documents can be hosted on websites, making it easier for others to understand your code and even contribute to it.\nVersioning Your Documentation As your code evolves, so should your documentation. Versioning your documentation ensures that it stays in sync with your codebase, providing accurate and up-to-date information. This is especially important when your project has multiple versions in use.\nSelf-Documenting Code: A First Line of Defense Before diving into comments, docstrings, and external documentation, your first line of defense should be writing self-documenting code. This practice involves using clear, descriptive names for variables, functions, and classes, as well as making effective use of type annotations. The idea is to write code that is its own best documentation.\nIn many modern programming paradigms, such as iOS development, self-documenting code is highly encouraged. The benefits are clear: it reduces the need for external documentation and makes the codebase easier to understand at a glance.\n# Example of self-documenting code def calculate_rectangle_area(length: float, width: float) -\u003e float: if length \u003c 0 or width \u003c 0: raise ValueError(\"Dimensions should be non-negative.\") return length * width In this example, the function name calculate_rectangle_area, the parameter names length and width, and the type annotations collectively provide a good deal of information about what the function does, without requiring the reader to look up external documentation.\nPerformance Optimization The Need for Speed and Efficiency While Python is known for its ease of use and rapid development capabilities, it’s not always the fastest language out there. However, with thoughtful optimization techniques, you can often make your Python code run faster and consume fewer resources, contributing to its robustness.\nAlgorithmic Improvements Before diving into code-level optimizations, it’s crucial to pick the right algorithms and data structures for your problem. No amount of micro-optimization can make up for an inherently inefficient algorithm.\n# Using a set to check for membership instead of a list # O(1) complexity instead of O(n) my_set = {1, 2, 3, 4, 5} print(4 in my_set) # Faster than using a list Loop Optimization Python offers several built-in functions and syntax that can make loops more efficient. Utilizing list comprehensions and functions like map() and filter() can often speed up iterative operations.\n# Using list comprehension for more efficient looping squared_numbers = [x*x for x in range(10)] Lazy Evaluation Generators and the itertools library can help you work with large data sets more efficiently by utilizing lazy evaluation. This allows you to iterate over data without loading it entirely into memory.\n# Using a generator to yield items one at a time def count_up_to(max): count = 1 while count \u003c= max: yield count count += 1 Profiling and Benchmarking Before and after making optimizations, it’s important to profile your code to identify bottlenecks and benchmark its performance. Python’s built-in cProfile module or third-party tools like Py-Spy can be extremely useful for this purpose.\n# Using cProfile to profile your Python script python -m cProfile your_script.py When to Optimize It’s often said that “premature optimization is the root of all evil.” While performance is important, it should not come at the cost of readability and maintainability. Always make sure your code is working correctly first, and then optimize the parts that are proven to be bottlenecks.\nBy focusing on performance optimization, you not only make your Python code faster but also more resource-efficient, contributing to its overall robustness and reliability.\nConclusion Writing robust Python code is an art that involves a blend of several key principles: Code Organization, Error Handling, Testing, Version Control, Dependency Management, Documentation, and Performance Optimization. Each of these elements serves as a pillar that upholds the integrity, maintainability, and efficiency of your codebase. As Python continues to permeate various sectors like web development, data science, and machine learning, the universal value of these principles cannot be overstated.\nRemember, robust code is not just about preventing errors but also about making your codebase resilient, understandable, and extendable. In essence, you’re not just writing code; you’re crafting software that is built to last and to adapt to future needs.\nNow that you’re armed with these best practices, the next step is to implement them in your own projects. Start by reviewing your current codebase, identifying areas that could benefit from these practices, and make the necessary adjustments. Challenge yourself to go beyond the basics, delve into additional resources, and contribute to a culture of coding excellence. Your future self—and anyone else who interacts with your code—will thank you.\nAdditional Resources To further enhance your Python coding practices, here are some additional resources you might find helpful:\nBooks: “Clean Code: A Handbook of Agile Software Craftsmanship” by Robert C. Martin\n“Robust Python” by Patrick Viafore\n","wordCount":"3796","inLanguage":"en","datePublished":"2023-09-08T12:49:12-06:00","dateModified":"2023-09-08T12:49:12-06:00","author":{"@type":"Person","name":"Nicholas Ollis"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.oll.is/posts/2023-09-04_robust_python/"},"publisher":{"@type":"Organization","name":"blog.oll.is","logo":{"@type":"ImageObject","url":"https://blog.oll.is/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.oll.is accesskey=h title="blog.oll.is (Alt + H)"><img src=https://blog.oll.is/android-chrome-512x512.png alt aria-label=logo height=35>blog.oll.is</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.oll.is/archives/ title=archives><span>archives</span></a></li><li><a href=https://blog.oll.is/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.oll.is/tags/ title=tags><span>tags</span></a></li><li><a href=https://nic.oll.is title=nic.oll.is><span>nic.oll.is</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.oll.is>Home</a>&nbsp;»&nbsp;<a href=https://blog.oll.is/posts/>Posts</a></div><h1 class=post-title>How to Write Python Code That Doesn’t Break: A Guide to Robustness</h1><div class=post-description>This guide offers insights on code organization, error handling, testing, and more, ensuring your Python projects stand the test of time.</div><div class=post-meta><span title='2023-09-08 12:49:12 -0600 -0600'>September 8, 2023</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;3796 words&nbsp;·&nbsp;Nicholas Ollis&nbsp;|&nbsp;<a href=https://github.com/nicollis/blog.oll.is/blob/main/content/posts/2023-09-04_robust_python/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a><ul><li><a href=#why-robust-code-matters>Why Robust Code Matters</a></li><li><a href=#the-importance-of-discipline-in-python>The Importance of Discipline in Python</a></li><li><a href=#what-is-robust-code>What Is &lsquo;Robust Code&rsquo;</a></li></ul></li><li><a href=#code-organization>Code Organization</a><ul><li><a href=#modularization>Modularization</a></li><li><a href=#naming-conventions>Naming Conventions</a></li><li><a href=#method-length-keep-it-short-and-sweet>Method Length: Keep It Short and Sweet</a></li></ul></li><li><a href=#error-handling>Error Handling</a><ul><li><a href=#pythons-error-prone-behavior>Python&rsquo;s Error-Prone Behavior</a></li><li><a href=#exception-handling>Exception Handling</a></li></ul></li><li><a href=#logging>Logging</a></li><li><a href=#using-types-for-robustness>Using Types for Robustness</a><ul><li><a href=#static-typing>Static Typing</a></li></ul></li><li><a href=#efficiency-in-iteration>Efficiency in Iteration</a><ul><li><a href=#list-comprehensions>List Comprehensions</a></li><li><a href=#dictionary-comprehensions>Dictionary Comprehensions</a></li></ul></li><li><a href=#protocols-and-class-signatures>Protocols and Class Signatures</a><ul><li><a href=#defining-protocols-and-duck-typing>Defining Protocols and Duck Typing</a></li><li><a href=#protocol-naming-conventions>Protocol Naming Conventions</a></li><li><a href=#class-signatures>Class Signatures</a></li></ul></li><li><a href=#testing>Testing</a><ul><li><a href=#the-non-negotiable-nature-of-unit-testing>The Non-Negotiable Nature of Unit Testing</a></li><li><a href=#unit-testing-in-depth>Unit Testing in Depth</a></li><li><a href=#mocking-an-essential-for-isolated-testing>Mocking: An Essential for Isolated Testing</a></li></ul></li><li><a href=#dependency-management-and-docker>Dependency Management and Docker</a><ul><li><a href=#best-practices-with-requirementstxt>Best Practices with <code>requirements.txt</code></a></li><li><a href=#virtual-environments>Virtual Environments</a></li><li><a href=#docker-the-superior-alternative-for-isolation>Docker: The Superior Alternative for Isolation</a></li></ul></li><li><a href=#documentation>Documentation</a><ul><li><a href=#the-unsung-hero-of-robust-code>The Unsung Hero of Robust Code</a></li><li><a href=#inline-comments-and-docstrings>Inline Comments and Docstrings</a></li><li><a href=#readme-files>README Files</a></li><li><a href=#api-documentation>API Documentation</a></li><li><a href=#versioning-your-documentation>Versioning Your Documentation</a></li><li><a href=#self-documenting-code-a-first-line-of-defense>Self-Documenting Code: A First Line of Defense</a></li></ul></li><li><a href=#performance-optimization>Performance Optimization</a><ul><li><a href=#the-need-for-speed-and-efficiency>The Need for Speed and Efficiency</a></li><li><a href=#algorithmic-improvements>Algorithmic Improvements</a></li><li><a href=#loop-optimization>Loop Optimization</a></li><li><a href=#lazy-evaluation>Lazy Evaluation</a></li><li><a href=#profiling-and-benchmarking>Profiling and Benchmarking</a></li><li><a href=#when-to-optimize>When to Optimize</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#additional-resources>Additional Resources</a><ul><li><a href=#books>Books:</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p><img loading=lazy src=./images/cover.png alt></p><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><h3 id=why-robust-code-matters>Why Robust Code Matters<a hidden class=anchor aria-hidden=true href=#why-robust-code-matters>#</a></h3><p>In the realm of software development, robust code serves as the bedrock of reliable and efficient systems. It&rsquo;s more than just writing code that &ldquo;works&rdquo;; it&rsquo;s about crafting code that can withstand a range of challenges including unexpected inputs, system changes, and long-term scaling. Robust code is integral for long-term maintainability, reducing technical debt, and creating a codebase that is not only functional but also resilient to bugs and errors. In a language as versatile as Python, which finds applications across various domains, the importance of robust code becomes even more pronounced.</p><h3 id=the-importance-of-discipline-in-python>The Importance of Discipline in Python<a hidden class=anchor aria-hidden=true href=#the-importance-of-discipline-in-python>#</a></h3><p>Python&rsquo;s flexibility and ease of use make it accessible for a wide range of applications, from web development to machine learning to automation. However, this very versatility can be a double-edged sword. The internet is rife with Python code examples that, while functional, may not follow best practices. For those new to Python or coming from different domains, these suboptimal examples can set a misleading precedent. That&rsquo;s why discipline is paramount. Being disciplined means adhering to best practices even when Python&rsquo;s flexibility allows you to bypass them. It&rsquo;s about going the extra mile to make your code not just functional, but robust, maintainable, and a pleasure to work with. This disciplined approach is foundational to all the robust coding practices that follow.</p><h3 id=what-is-robust-code>What Is &lsquo;Robust Code&rsquo;<a hidden class=anchor aria-hidden=true href=#what-is-robust-code>#</a></h3><p>In Python, robust code is a combination of resilience, maintainability, and readability. Resilient code can gracefully handle unexpected situations; maintainable code is structured to allow easy updates and debugging; readable code is self-explanatory and easy for other developers to understand. When you achieve these three pillars, you create a robust codebase that serves as a strong foundation for any project, big or small.</p><h2 id=code-organization>Code Organization<a hidden class=anchor aria-hidden=true href=#code-organization>#</a></h2><h3 id=modularization>Modularization<a hidden class=anchor aria-hidden=true href=#modularization>#</a></h3><p>In Python, modular code is not just a best practice—it&rsquo;s a sanity-saving necessity, especially for larger projects. Modularization involves breaking down your code into separate functions, modules, and packages, each responsible for a specific piece of functionality. This makes your code easier to test, debug, and extend. For example, a function that calculates the area of a circle should only do just that, making it reusable and easier to test.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Good Practice</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>calculate_area</span><span class=p>(</span><span class=n>radius</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mf>3.14159</span> <span class=o>*</span> <span class=n>radius</span> <span class=o>*</span> <span class=n>radius</span>
</span></span></code></pre></div><h3 id=naming-conventions>Naming Conventions<a hidden class=anchor aria-hidden=true href=#naming-conventions>#</a></h3><p>Good naming conventions are like good hygiene for your code; they make it easier to read, understand, and collaborate on. Python has a set of naming conventions outlined in PEP 8, which most Pythonistas try to follow.</p><p>For classes, use <code>CamelCase</code>:</p><ul><li>Good: <code>class UserProfile:</code></li><li>Bad: <code>class user_profile:</code></li></ul><p>For functions and parameters, use <code>snake_case</code>:</p><ul><li>Good: <code>def calculate_area(radius):</code></li><li>Bad: <code>def CalculateArea(Radius):</code></li></ul><p>For private methods and private instance variables, prepend a single underscore:</p><ul><li>Good: <code>_private_method()</code>, <code>_private_variable</code></li><li>Bad: <code>privatemethod()</code>, <code>privateVariable</code></li></ul><p>By adhering to these naming conventions, you make your code more accessible and understandable to other Python developers, thereby contributing to its robustness.</p><h3 id=method-length-keep-it-short-and-sweet>Method Length: Keep It Short and Sweet<a hidden class=anchor aria-hidden=true href=#method-length-keep-it-short-and-sweet>#</a></h3><p>One of the simplest yet most impactful measures of code organization is the length of your methods or functions. A common best practice is to keep method lengths between 20 to 30 lines. This isn&rsquo;t a strict rule, but rather a guideline to encourage developers to write methods that do one thing and do it well.</p><p>Shorter methods have several advantages:</p><ol><li><strong>Readability:</strong> They are easier to read and understand. When a method is concise, its purpose is usually clear.</li><li><strong>Maintainability:</strong> Smaller, focused methods are easier to modify without introducing bugs.</li><li><strong>Reusability:</strong> Short methods that perform a specific function are more likely to be reusable in different parts of the codebase.</li><li><strong>Testability:</strong> Methods that stick to a single responsibility are simpler to test, leading to more robust code.</li></ol><p>It&rsquo;s worth noting that, sometimes, a method may need to exceed this guideline, especially if making it shorter would compromise clarity. However, if you regularly find yourself writing lengthy methods, it might be an indicator to reconsider how you&rsquo;re structuring your code.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Good Practice</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>add_numbers</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Potential Red Flag</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>process_data</span><span class=p>(</span><span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># ... 50 lines of data processing ...</span>
</span></span></code></pre></div><p>In the example above, the <code>add_numbers</code> function is concise and has a clear purpose, while the <code>process_data</code> function might be doing too much and could potentially be broken down into smaller, more focused methods.</p><h2 id=error-handling>Error Handling<a hidden class=anchor aria-hidden=true href=#error-handling>#</a></h2><h3 id=pythons-error-prone-behavior>Python&rsquo;s Error-Prone Behavior<a hidden class=anchor aria-hidden=true href=#pythons-error-prone-behavior>#</a></h3><p>Before diving into best practices for error handling, it&rsquo;s crucial to understand that Python can be error-prone in ways that might differ from other programming languages. For example, when searching for an item in an array, languages like C++ or JavaScript return a value like <code>-1</code> to indicate the item is not found. However, Python throws a <code>ValueError</code> exception in such cases. This behavior necessitates a more proactive approach to error handling.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// C++ returns -1 when an item is not found in an array
</span></span></span><span class=line><span class=cl><span class=c1>// C++ Code
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>find</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>v</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>it</span> <span class=o>!=</span> <span class=n>v</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Found
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Not found, it would be v.end()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Python throws an error when an item is not found in a list</span>
</span></span><span class=line><span class=cl><span class=c1># Python Code</span>
</span></span><span class=line><span class=cl><span class=n>arr</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>index</span> <span class=o>=</span> <span class=n>arr</span><span class=o>.</span><span class=n>index</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>except</span> <span class=ne>ValueError</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Item not found.&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>Being aware of these idiosyncrasies is the first step in writing robust Python code that can handle and recover from errors gracefully.</p><h3 id=exception-handling>Exception Handling<a hidden class=anchor aria-hidden=true href=#exception-handling>#</a></h3><p>One of the hallmarks of robust code is its ability to anticipate and gracefully handle errors. In Python, this is typically done through exception handling using the <code>try</code>, <code>except</code>, <code>finally</code> blocks. Effective exception handling prevents your program from crashing when it encounters an error, allowing it to either recover or exit gracefully, providing useful information about what went wrong. This is invaluable for debugging and for providing meaningful feedback to users.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Example of Exception Handling</span>
</span></span><span class=line><span class=cl><span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=mi>10</span> <span class=o>/</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=k>except</span> <span class=ne>ZeroDivisionError</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Caught a division by zero error.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>finally</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Cleanup code, if any, goes here.&#34;</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=logging>Logging<a hidden class=anchor aria-hidden=true href=#logging>#</a></h2><p>Logging is another critical component of robust code. While exceptions handle the &ldquo;exceptional&rdquo; cases, logging helps you understand the regular flow and the anomalies in your program. Effective logging can help you debug errors, understand program flow, and even gather usage statistics. Python’s built-in <code>logging</code> library is a versatile tool for various logging levels (DEBUG, INFO, WARNING, ERROR, CRITICAL).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Example of Logging</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>logging</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>logging</span><span class=o>.</span><span class=n>basicConfig</span><span class=p>(</span><span class=n>level</span><span class=o>=</span><span class=n>logging</span><span class=o>.</span><span class=n>INFO</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>divide</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=n>a</span> <span class=o>/</span> <span class=n>b</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span> <span class=ne>ZeroDivisionError</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>logging</span><span class=o>.</span><span class=n>error</span><span class=p>(</span><span class=s2>&#34;Division by zero!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></div><h2 id=using-types-for-robustness>Using Types for Robustness<a hidden class=anchor aria-hidden=true href=#using-types-for-robustness>#</a></h2><h3 id=static-typing>Static Typing<a hidden class=anchor aria-hidden=true href=#static-typing>#</a></h3><p>Python, traditionally a dynamically typed language, introduced optional static typing in Python 3.5 via PEP 484. While the Python runtime itself doesn&rsquo;t enforce these type hints, they serve multiple purposes that contribute to writing robust code. First, type hints make your code self-documenting. Anyone reading the code can immediately understand what types of arguments a function expects and what it returns, making the code more maintainable and less prone to bugs. Second, type hints enable better IDE support. Features like auto-completion, linting, and error checking become more accurate when the IDE knows the expected types. Last but not least, type hints allow for early detection of bugs. Tools like mypy can be used to statically analyze your code, catching potential type errors before the code is even run.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Example of Static Typing</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>typing</span> <span class=kn>import</span> <span class=n>List</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>sum_elements</span><span class=p>(</span><span class=n>elements</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=n>elements</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Using mypy for static type checking</span>
</span></span><span class=line><span class=cl><span class=c1># Command: mypy your_script.py</span>
</span></span></code></pre></div><h2 id=efficiency-in-iteration>Efficiency in Iteration<a hidden class=anchor aria-hidden=true href=#efficiency-in-iteration>#</a></h2><h3 id=list-comprehensions>List Comprehensions<a hidden class=anchor aria-hidden=true href=#list-comprehensions>#</a></h3><p>Python’s list comprehensions are not just syntactic sugar; they are a more efficient way to perform operations on lists (or any iterable), compared to traditional <code>for</code> loops. The speed advantage comes from the internal optimizations that Python performs, reducing the overhead of function calls and lookups in the global namespace. This might not be noticeable in smaller lists, but for larger datasets, the difference can be significant.</p><p>List comprehensions are also more readable and concise, allowing you to express complex transformations in a single line of code. However, it&rsquo;s important to strike a balance. Overly complex list comprehensions can become hard to read and maintain.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Using a for loop</span>
</span></span><span class=line><span class=cl><span class=n>squares</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>squares</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>x</span> <span class=o>*</span> <span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Using List Comprehension</span>
</span></span><span class=line><span class=cl><span class=n>squares</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=o>*</span> <span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Complex example (not recommended for readability)</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=p>[(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=k>for</span> <span class=n>y</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=k>if</span> <span class=n>x</span> <span class=o>!=</span> <span class=n>y</span><span class=p>]</span>
</span></span></code></pre></div><p>By opting for list comprehensions where appropriate, you not only make your code more efficient but also contribute to its readability and maintainability, thereby enhancing its robustness.</p><h3 id=dictionary-comprehensions>Dictionary Comprehensions<a hidden class=anchor aria-hidden=true href=#dictionary-comprehensions>#</a></h3><p>Just like list comprehensions, Python also offers dictionary comprehensions to create dictionaries in a more efficient and readable manner. Dictionary comprehensions are a way to transform one dictionary into another dictionary, filtering keys, and values and applying a function to the keys and values. They offer the same benefits as list comprehensions: internal optimizations for better performance and concise, readable code.</p><p>Using dictionary comprehensions, you can transform complex loops that involve dictionary keys and values into a single line of code. However, as with list comprehensions, keeping them simple is essential for readability and maintainability.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Using a for loop to create a dictionary</span>
</span></span><span class=line><span class=cl><span class=n>squares_dict</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>6</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>squares_dict</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>=</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Using Dictionary Comprehension</span>
</span></span><span class=line><span class=cl><span class=n>squares_dict</span> <span class=o>=</span> <span class=p>{</span><span class=n>x</span><span class=p>:</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>6</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Complex example (not recommended for readability)</span>
</span></span><span class=line><span class=cl><span class=n>result_dict</span> <span class=o>=</span> <span class=p>{</span><span class=n>x</span><span class=p>:</span> <span class=s1>&#39;even&#39;</span> <span class=k>if</span> <span class=n>x</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span> <span class=k>else</span> <span class=s1>&#39;odd&#39;</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>6</span><span class=p>)}</span>
</span></span></code></pre></div><p>By employing list and dictionary comprehensions where they make sense, you contribute to the efficiency, readability, and robustness of your Python code.</p><h2 id=protocols-and-class-signatures>Protocols and Class Signatures<a hidden class=anchor aria-hidden=true href=#protocols-and-class-signatures>#</a></h2><h3 id=defining-protocols-and-duck-typing>Defining Protocols and Duck Typing<a hidden class=anchor aria-hidden=true href=#defining-protocols-and-duck-typing>#</a></h3><p>In Python, the concept of protocols plays a significant role in writing code that is both robust and maintainable. At its core, a protocol specifies a contract that classes should adhere to, much like an interface in other programming languages. However, Python&rsquo;s dynamic nature has always allowed for a more lenient approach known as &ldquo;duck typing.&rdquo;</p><p>Duck typing is a programming concept where the type or class of an object is determined by its behavior (methods and properties) rather than its class inheritance. While this is a powerful feature, it can lead to issues if the expected behavior is not clearly defined or understood.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Duck Typing Example in Python</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Bird</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>make_sound</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Some generic bird sound&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Duck</span><span class=p>(</span><span class=n>Bird</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>make_sound</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Quack&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>animal_sound</span><span class=p>(</span><span class=n>animal</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>animal</span><span class=o>.</span><span class=n>make_sound</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>animal</span> <span class=o>=</span> <span class=n>Duck</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>animal_sound</span><span class=p>(</span><span class=n>animal</span><span class=p>)</span>  <span class=c1># Output: Quack</span>
</span></span></code></pre></div><p>Duck typing is not unique to Python; it&rsquo;s also prevalent in languages like Ruby, JavaScript, and Groovy. However, what sets Python apart is its support for making these implicit contracts explicit through protocols and type hints.</p><p>To mitigate such issues, Python allows for making these implicit &ldquo;contracts&rdquo; explicit through protocols. Here&rsquo;s an example of an implicit form of a protocol:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Implicit Protocol Example</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>typing</span> <span class=kn>import</span> <span class=n>Protocol</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Drawable</span><span class=p>(</span><span class=n>Protocol</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>draw</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># A class adhering to the Drawable protocol implicitly</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Circle</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>draw</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Drawing a circle.&#34;</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=protocol-naming-conventions>Protocol Naming Conventions<a hidden class=anchor aria-hidden=true href=#protocol-naming-conventions>#</a></h3><p>When it comes to naming protocols, adopting an action-oriented convention with an &ldquo;-able&rdquo; suffix (e.g., <code>Drawable</code>, <code>Iterable</code>, <code>Callable</code>) can be helpful. This makes it clear what behavior is expected from a class that adheres to the protocol.</p><h3 id=class-signatures>Class Signatures<a hidden class=anchor aria-hidden=true href=#class-signatures>#</a></h3><p>While Python&rsquo;s flexibility allows you to be implicit about adherence to a protocol, adopting a disciplined approach of being explicit in your class signatures elevates the robustness of your code. Explicitly stating that a class adheres to a protocol removes any ambiguity and assumptions, making the code more straightforward to read, debug, and maintain.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Explicitly stating that Circle adheres to the Drawable protocol</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Circle</span><span class=p>(</span><span class=n>Drawable</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>draw</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Drawing a circle.&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>By taking the extra step to define protocols and explicitly mention them in your class signatures, you create a codebase that is easier to navigate, less prone to errors, and more maintainable in the long run.</p><h2 id=testing>Testing<a hidden class=anchor aria-hidden=true href=#testing>#</a></h2><h3 id=the-non-negotiable-nature-of-unit-testing>The Non-Negotiable Nature of Unit Testing<a hidden class=anchor aria-hidden=true href=#the-non-negotiable-nature-of-unit-testing>#</a></h3><p>While various aspects of coding best practices may be subject to interpretation or specific use-cases, the role of unit testing is non-negotiable for writing robust code. At a minimum, &ldquo;happy path&rdquo; testing, which tests the expected behavior under normal conditions, should always be in place. These basic tests not only verify that your code works as intended but also lay the groundwork for future testing. When bugs are discovered, having an existing unit testing framework makes it straightforward to add new tests that capture these specific issues. This ensures that once a bug is fixed, it stays fixed, enhancing the code&rsquo;s long-term reliability.</p><h3 id=unit-testing-in-depth>Unit Testing in Depth<a hidden class=anchor aria-hidden=true href=#unit-testing-in-depth>#</a></h3><p>Unit tests are geared towards verifying the smallest units of code in isolation—often individual methods or functions. These tests serve multiple purposes:</p><ul><li><strong>Safety Net:</strong> Unit tests catch regressions and errors before they reach production, acting as a first line of defense against bugs.</li><li><strong>Documentation:</strong> Well-written unit tests serve as a form of documentation, clearly outlining what each function or method is supposed to accomplish.</li><li><strong>Simplifies Debugging:</strong> When a test fails, you only need to consider the latest changes, making debugging quicker and easier.</li></ul><p>In Python, you can write unit tests using the built-in <code>unittest</code> framework, or you can use third-party libraries like <code>pytest</code> for more advanced features and simpler syntax.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Example of a simple unit test using unittest</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>unittest</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>add</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>TestAddition</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>test_add_positive_numbers</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>),</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>test_add_zero</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>),</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>test_add_negative_numbers</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>),</span> <span class=o>-</span><span class=mi>2</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=mocking-an-essential-for-isolated-testing>Mocking: An Essential for Isolated Testing<a hidden class=anchor aria-hidden=true href=#mocking-an-essential-for-isolated-testing>#</a></h3><p>Mocking is a powerful technique for isolating the code under test. By replacing external dependencies with mock objects, you can focus solely on the logic you&rsquo;re testing. This is crucial for several reasons:</p><ul><li><strong>Isolation:</strong> Mocking external services or modules ensures that your tests are not affected by their behavior or state.</li><li><strong>Speed:</strong> Tests run faster because they don&rsquo;t have to wait for real database queries or API calls.</li><li><strong>Reliability:</strong> Mocking creates a controlled environment for your tests, ensuring that they produce consistent results.</li></ul><p>Python’s <code>unittest</code> library includes a <code>Mock</code> class for creating simple object mocks. For more fine-grained control over object behavior, libraries like <code>pytest-mock</code> or <code>unittest.mock</code> offer advanced features like spy objects and mock patching.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Example of mocking using unittest</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>unittest</span> <span class=kn>import</span> <span class=n>TestCase</span><span class=p>,</span> <span class=n>mock</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fetch_data</span><span class=p>(</span><span class=n>api_client</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>api_client</span><span class=o>.</span><span class=n>get_data</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>TestFetchData</span><span class=p>(</span><span class=n>TestCase</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nd>@mock.patch</span><span class=p>(</span><span class=s1>&#39;module_name.api_client&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>test_fetch_data</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>mock_client</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>mock_client</span><span class=o>.</span><span class=n>get_data</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=s1>&#39;some data&#39;</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=n>fetch_data</span><span class=p>(</span><span class=n>mock_client</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=s1>&#39;some data&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p>By making unit testing and mocking non-negotiable parts of your development process, you&rsquo;re not just writing code—you&rsquo;re crafting robust, reliable, and maintainable software.</p><h2 id=dependency-management-and-docker>Dependency Management and Docker<a hidden class=anchor aria-hidden=true href=#dependency-management-and-docker>#</a></h2><p>In Python projects, dependency management is essential for ensuring consistent behavior across different environments. The <code>requirements.txt</code> file is a widely used method for specifying project dependencies and their versions.</p><h3 id=best-practices-with-requirementstxt>Best Practices with <code>requirements.txt</code><a hidden class=anchor aria-hidden=true href=#best-practices-with-requirementstxt>#</a></h3><ul><li><strong>Pin Versions:</strong> Specifying exact package versions ensures that your application behaves consistently across different setups.</li></ul><pre tabindex=0><code># requirements.txt with pinned versions
Flask==1.1.2
</code></pre><ul><li><strong>Use Comments:</strong> Comments in <code>requirements.txt</code> can describe why a particular package or version is necessary, aiding future maintenance.</li></ul><pre tabindex=0><code># requirements.txt with comments
Flask==1.1.2  # Needed for web API
</code></pre><h3 id=virtual-environments>Virtual Environments<a hidden class=anchor aria-hidden=true href=#virtual-environments>#</a></h3><p>Python&rsquo;s native virtual environments, such as those created using <code>venv</code>, are a common way to isolate project-specific dependencies. While effective, they only handle Python packages and not other system dependencies.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Creating a virtual environment</span>
</span></span><span class=line><span class=cl>python -m venv myenv
</span></span></code></pre></div><h3 id=docker-the-superior-alternative-for-isolation>Docker: The Superior Alternative for Isolation<a hidden class=anchor aria-hidden=true href=#docker-the-superior-alternative-for-isolation>#</a></h3><p>Docker containers take environment isolation to the next level. Unlike Python virtual environments, which only isolate Python packages, Docker containers encapsulate the entire application environment. This includes the operating system, system libraries, databases, and other services your application might interact with.</p><p>Here&rsquo;s why Docker should be your go-to choice:</p><ul><li><strong>Environment Consistency:</strong> Docker ensures your application behaves the same way regardless of where it runs, eliminating the &ldquo;it works on my machine&rdquo; problem.</li><li><strong>Ease of Deployment:</strong> Docker containers can be easily shared, making deployment across different systems or servers straightforward.</li><li><strong>Microservices:</strong> For applications based on micro-services architecture, Docker simplifies service management, as each service can reside in its own container.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Example Dockerfile for a Python application</span>
</span></span><span class=line><span class=cl>FROM python:3.8
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>WORKDIR /app
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>COPY requirements.txt .
</span></span><span class=line><span class=cl>RUN pip install --no-cache-dir -r requirements.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>COPY . .
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>CMD <span class=o>[</span><span class=s2>&#34;python&#34;</span>, <span class=s2>&#34;your_app.py&#34;</span><span class=o>]</span>
</span></span></code></pre></div><p>By opting for Docker over traditional Python virtual environments, you&rsquo;re not just isolating your Python application; you&rsquo;re making it portable, easy to deploy, and robust, thereby ensuring its reliability and maintainability.</p><h2 id=documentation>Documentation<a hidden class=anchor aria-hidden=true href=#documentation>#</a></h2><h3 id=the-unsung-hero-of-robust-code>The Unsung Hero of Robust Code<a hidden class=anchor aria-hidden=true href=#the-unsung-hero-of-robust-code>#</a></h3><p>While code is written for machines to execute, it is read and understood by humans. Good documentation acts as a guide, making it easier for you (and others) to understand the code&rsquo;s purpose, architecture, and nuances. Without adequate documentation, even the most well-designed codebase can become a labyrinth that is hard to navigate and risky to modify.</p><h3 id=inline-comments-and-docstrings>Inline Comments and Docstrings<a hidden class=anchor aria-hidden=true href=#inline-comments-and-docstrings>#</a></h3><p>Inline comments and docstrings should be the starting point of any documentation effort. Comments can offer context or explain complex pieces of code, while docstrings provide an overview of modules, classes, and functions.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>calculate_area</span><span class=p>(</span><span class=n>length</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span> <span class=n>width</span><span class=p>:</span> <span class=nb>float</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>float</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    Calculate the area of a rectangle.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    This function takes the length and width of a rectangle and returns its area.
</span></span></span><span class=line><span class=cl><span class=s2>    The function assumes that the parameters provided are positive numbers.
</span></span></span><span class=line><span class=cl><span class=s2>    Zero is considered an acceptable value for either length or width but will result in an area of zero.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    :param length: The length of the rectangle.
</span></span></span><span class=line><span class=cl><span class=s2>    :type length: float
</span></span></span><span class=line><span class=cl><span class=s2>    :param width: The width of the rectangle.
</span></span></span><span class=line><span class=cl><span class=s2>    :type width: float
</span></span></span><span class=line><span class=cl><span class=s2>    :return: The area of the rectangle.
</span></span></span><span class=line><span class=cl><span class=s2>    :rtype: float
</span></span></span><span class=line><span class=cl><span class=s2>    :raises ValueError: If either length or width is negative.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    :Example:
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    &gt;&gt;&gt; calculate_area(10, 5)
</span></span></span><span class=line><span class=cl><span class=s2>    50.0
</span></span></span><span class=line><span class=cl><span class=s2>    &gt;&gt;&gt; calculate_area(0, 5)
</span></span></span><span class=line><span class=cl><span class=s2>    0.0
</span></span></span><span class=line><span class=cl><span class=s2>    &gt;&gt;&gt; calculate_area(-1, 5)
</span></span></span><span class=line><span class=cl><span class=s2>    ValueError: Dimensions should be non-negative.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>length</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=ow>or</span> <span class=n>width</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&#34;Dimensions should be non-negative.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>length</span> <span class=o>*</span> <span class=n>width</span>
</span></span></code></pre></div><h3 id=readme-files>README Files<a hidden class=anchor aria-hidden=true href=#readme-files>#</a></h3><p>Every project should have a README file that serves as an introduction to your project. It should contain essential information like what the project does, how to set it up, and how to use it, providing a roadmap to your codebase.</p><h3 id=api-documentation>API Documentation<a hidden class=anchor aria-hidden=true href=#api-documentation>#</a></h3><p>For larger projects or libraries, generating API documentation using tools like Sphinx can offer a more organized and navigable format. These documents can be hosted on websites, making it easier for others to understand your code and even contribute to it.</p><h3 id=versioning-your-documentation>Versioning Your Documentation<a hidden class=anchor aria-hidden=true href=#versioning-your-documentation>#</a></h3><p>As your code evolves, so should your documentation. Versioning your documentation ensures that it stays in sync with your codebase, providing accurate and up-to-date information. This is especially important when your project has multiple versions in use.</p><h3 id=self-documenting-code-a-first-line-of-defense>Self-Documenting Code: A First Line of Defense<a hidden class=anchor aria-hidden=true href=#self-documenting-code-a-first-line-of-defense>#</a></h3><p>Before diving into comments, docstrings, and external documentation, your first line of defense should be writing self-documenting code. This practice involves using clear, descriptive names for variables, functions, and classes, as well as making effective use of type annotations. The idea is to write code that is its own best documentation.</p><p>In many modern programming paradigms, such as iOS development, self-documenting code is highly encouraged. The benefits are clear: it reduces the need for external documentation and makes the codebase easier to understand at a glance.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Example of self-documenting code</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>calculate_rectangle_area</span><span class=p>(</span><span class=n>length</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span> <span class=n>width</span><span class=p>:</span> <span class=nb>float</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>float</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>length</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=ow>or</span> <span class=n>width</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&#34;Dimensions should be non-negative.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>length</span> <span class=o>*</span> <span class=n>width</span>
</span></span></code></pre></div><p>In this example, the function name <code>calculate_rectangle_area</code>, the parameter names <code>length</code> and <code>width</code>, and the type annotations collectively provide a good deal of information about what the function does, without requiring the reader to look up external documentation.</p><h2 id=performance-optimization>Performance Optimization<a hidden class=anchor aria-hidden=true href=#performance-optimization>#</a></h2><h3 id=the-need-for-speed-and-efficiency>The Need for Speed and Efficiency<a hidden class=anchor aria-hidden=true href=#the-need-for-speed-and-efficiency>#</a></h3><p>While Python is known for its ease of use and rapid development capabilities, it&rsquo;s not always the fastest language out there. However, with thoughtful optimization techniques, you can often make your Python code run faster and consume fewer resources, contributing to its robustness.</p><h3 id=algorithmic-improvements>Algorithmic Improvements<a hidden class=anchor aria-hidden=true href=#algorithmic-improvements>#</a></h3><p>Before diving into code-level optimizations, it&rsquo;s crucial to pick the right algorithms and data structures for your problem. No amount of micro-optimization can make up for an inherently inefficient algorithm.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Using a set to check for membership instead of a list</span>
</span></span><span class=line><span class=cl><span class=c1># O(1) complexity instead of O(n)</span>
</span></span><span class=line><span class=cl><span class=n>my_set</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=mi>4</span> <span class=ow>in</span> <span class=n>my_set</span><span class=p>)</span>  <span class=c1># Faster than using a list</span>
</span></span></code></pre></div><h3 id=loop-optimization>Loop Optimization<a hidden class=anchor aria-hidden=true href=#loop-optimization>#</a></h3><p>Python offers several built-in functions and syntax that can make loops more efficient. Utilizing list comprehensions and functions like <code>map()</code> and <code>filter()</code> can often speed up iterative operations.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Using list comprehension for more efficient looping</span>
</span></span><span class=line><span class=cl><span class=n>squared_numbers</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span><span class=o>*</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=p>)]</span>
</span></span></code></pre></div><h3 id=lazy-evaluation>Lazy Evaluation<a hidden class=anchor aria-hidden=true href=#lazy-evaluation>#</a></h3><p>Generators and the <code>itertools</code> library can help you work with large data sets more efficiently by utilizing lazy evaluation. This allows you to iterate over data without loading it entirely into memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Using a generator to yield items one at a time</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>count_up_to</span><span class=p>(</span><span class=nb>max</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>count</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>count</span> <span class=o>&lt;=</span> <span class=nb>max</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>yield</span> <span class=n>count</span>
</span></span><span class=line><span class=cl>        <span class=n>count</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span></code></pre></div><h3 id=profiling-and-benchmarking>Profiling and Benchmarking<a hidden class=anchor aria-hidden=true href=#profiling-and-benchmarking>#</a></h3><p>Before and after making optimizations, it&rsquo;s important to profile your code to identify bottlenecks and benchmark its performance. Python&rsquo;s built-in <code>cProfile</code> module or third-party tools like <code>Py-Spy</code> can be extremely useful for this purpose.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Using cProfile to profile your Python script</span>
</span></span><span class=line><span class=cl>python -m cProfile your_script.py
</span></span></code></pre></div><h3 id=when-to-optimize>When to Optimize<a hidden class=anchor aria-hidden=true href=#when-to-optimize>#</a></h3><p>It&rsquo;s often said that &ldquo;premature optimization is the root of all evil.&rdquo; While performance is important, it should not come at the cost of readability and maintainability. Always make sure your code is working correctly first, and then optimize the parts that are proven to be bottlenecks.</p><p>By focusing on performance optimization, you not only make your Python code faster but also more resource-efficient, contributing to its overall robustness and reliability.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Writing robust Python code is an art that involves a blend of several key principles: <strong>Code Organization</strong>, <strong>Error Handling</strong>, <strong>Testing</strong>, <strong>Version Control</strong>, <strong>Dependency Management</strong>, <strong>Documentation</strong>, and <strong>Performance Optimization</strong>. Each of these elements serves as a pillar that upholds the integrity, maintainability, and efficiency of your codebase. As Python continues to permeate various sectors like web development, data science, and machine learning, the universal value of these principles cannot be overstated.</p><p>Remember, robust code is not just about preventing errors but also about making your codebase resilient, understandable, and extendable. In essence, you&rsquo;re not just writing code; you&rsquo;re crafting software that is built to last and to adapt to future needs.</p><p>Now that you&rsquo;re armed with these best practices, the next step is to implement them in your own projects. Start by reviewing your current codebase, identifying areas that could benefit from these practices, and make the necessary adjustments. Challenge yourself to go beyond the basics, delve into additional resources, and contribute to a culture of coding excellence. Your future self—and anyone else who interacts with your code—will thank you.</p><h2 id=additional-resources>Additional Resources<a hidden class=anchor aria-hidden=true href=#additional-resources>#</a></h2><p>To further enhance your Python coding practices, here are some additional resources you might find helpful:</p><h3 id=books>Books:<a hidden class=anchor aria-hidden=true href=#books>#</a></h3><p>&ldquo;Clean Code: A Handbook of Agile Software Craftsmanship&rdquo; by Robert C. Martin<br>“Robust Python” by Patrick Viafore</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.oll.is/tags/python/>Python</a></li><li><a href=https://blog.oll.is/tags/robust-code/>Robust Code</a></li><li><a href=https://blog.oll.is/tags/best-practices/>Best Practices</a></li><li><a href=https://blog.oll.is/tags/coding-standards/>Coding Standards</a></li></ul><nav class=paginav><a class=prev href=https://blog.oll.is/posts/2023-09-15_apac_data_regulations/><span class=title>« Prev</span><br><span>In-depth Comparison of APAC International Data Regulations</span></a>
<a class=next href=https://blog.oll.is/posts/2023-09-01_comparison-of-different-idr/><span class=title>Next »</span><br><span>Comparison of Different International Data Regulations</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share How to Write Python Code That Doesn’t Break: A Guide to Robustness on twitter" href="https://twitter.com/intent/tweet/?text=How%20to%20Write%20Python%20Code%20That%20Doesn%e2%80%99t%20Break%3a%20A%20Guide%20to%20Robustness&url=https%3a%2f%2fblog.oll.is%2fposts%2f2023-09-04_robust_python%2f&hashtags=Python%2cRobustCode%2cBestPractices%2cCodingStandards"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How to Write Python Code That Doesn’t Break: A Guide to Robustness on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.oll.is%2fposts%2f2023-09-04_robust_python%2f&title=How%20to%20Write%20Python%20Code%20That%20Doesn%e2%80%99t%20Break%3a%20A%20Guide%20to%20Robustness&summary=How%20to%20Write%20Python%20Code%20That%20Doesn%e2%80%99t%20Break%3a%20A%20Guide%20to%20Robustness&source=https%3a%2f%2fblog.oll.is%2fposts%2f2023-09-04_robust_python%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How to Write Python Code That Doesn’t Break: A Guide to Robustness on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.oll.is%2fposts%2f2023-09-04_robust_python%2f&title=How%20to%20Write%20Python%20Code%20That%20Doesn%e2%80%99t%20Break%3a%20A%20Guide%20to%20Robustness"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How to Write Python Code That Doesn’t Break: A Guide to Robustness on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.oll.is%2fposts%2f2023-09-04_robust_python%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How to Write Python Code That Doesn’t Break: A Guide to Robustness on whatsapp" href="https://api.whatsapp.com/send?text=How%20to%20Write%20Python%20Code%20That%20Doesn%e2%80%99t%20Break%3a%20A%20Guide%20to%20Robustness%20-%20https%3a%2f%2fblog.oll.is%2fposts%2f2023-09-04_robust_python%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How to Write Python Code That Doesn’t Break: A Guide to Robustness on telegram" href="https://telegram.me/share/url?text=How%20to%20Write%20Python%20Code%20That%20Doesn%e2%80%99t%20Break%3a%20A%20Guide%20to%20Robustness&url=https%3a%2f%2fblog.oll.is%2fposts%2f2023-09-04_robust_python%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//blog-oll-is.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.oll.is>blog.oll.is</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>